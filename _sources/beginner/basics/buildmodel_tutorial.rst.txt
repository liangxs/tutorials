
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "beginner/basics/buildmodel_tutorial.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_beginner_basics_buildmodel_tutorial.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_beginner_basics_buildmodel_tutorial.py:


`Learn the Basics <intro.html>`_ ||
`Quickstart <quickstart_tutorial.html>`_ ||
`Tensors <tensorqs_tutorial.html>`_ ||
`Datasets & DataLoaders <data_tutorial.html>`_ ||
`Transforms <transforms_tutorial.html>`_ ||
**Build Model** ||
`Autograd <autogradqs_tutorial.html>`_ ||
`Optimization <optimization_tutorial.html>`_ ||
`Save & Load Model <saveloadrun_tutorial.html>`_

Build the Neural Network
========================

Neural networks comprise of layers/modules that perform operations on data.
The `torch.nn <https://pytorch.org/docs/stable/nn.html>`_ namespace provides all the building blocks you need to
build your own neural network. Every module in PyTorch subclasses the `nn.Module <https://pytorch.org/docs/stable/generated/torch.nn.Module.html>`_.
A neural network is a module itself that consists of other modules (layers). This nested structure allows for
building and managing complex architectures easily.

In the following sections, we'll build a neural network to classify images in the FashionMNIST dataset.

.. GENERATED FROM PYTHON SOURCE LINES 24-32

.. code-block:: Python


    import os
    import torch
    from torch import nn
    from torch.utils.data import DataLoader
    from torchvision import datasets, transforms









.. GENERATED FROM PYTHON SOURCE LINES 33-37

Get Device for Training
-----------------------
We want to be able to train our model on an `accelerator <https://pytorch.org/docs/stable/torch.html#accelerators>`__
such as CUDA, MPS, MTIA, or XPU. If the current accelerator is available, we will use it. Otherwise, we use the CPU.

.. GENERATED FROM PYTHON SOURCE LINES 37-41

.. code-block:: Python


    device = torch.accelerator.current_accelerator().type if torch.accelerator.is_available() else "cpu"
    print(f"Using {device} device")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Using cuda device




.. GENERATED FROM PYTHON SOURCE LINES 42-47

Define the Class
-------------------------
We define our neural network by subclassing ``nn.Module``, and
initialize the neural network layers in ``__init__``. Every ``nn.Module`` subclass implements
the operations on input data in the ``forward`` method.

.. GENERATED FROM PYTHON SOURCE LINES 47-65

.. code-block:: Python


    class NeuralNetwork(nn.Module):
        def __init__(self):
            super().__init__()
            self.flatten = nn.Flatten()
            self.linear_relu_stack = nn.Sequential(
                nn.Linear(28*28, 512),
                nn.ReLU(),
                nn.Linear(512, 512),
                nn.ReLU(),
                nn.Linear(512, 10),
            )

        def forward(self, x):
            x = self.flatten(x)
            logits = self.linear_relu_stack(x)
            return logits








.. GENERATED FROM PYTHON SOURCE LINES 66-68

We create an instance of ``NeuralNetwork``, and move it to the ``device``, and print
its structure.

.. GENERATED FROM PYTHON SOURCE LINES 68-73

.. code-block:: Python


    model = NeuralNetwork().to(device)
    print(model)






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    NeuralNetwork(
      (flatten): Flatten(start_dim=1, end_dim=-1)
      (linear_relu_stack): Sequential(
        (0): Linear(in_features=784, out_features=512, bias=True)
        (1): ReLU()
        (2): Linear(in_features=512, out_features=512, bias=True)
        (3): ReLU()
        (4): Linear(in_features=512, out_features=10, bias=True)
      )
    )




.. GENERATED FROM PYTHON SOURCE LINES 74-80

To use the model, we pass it the input data. This executes the model's ``forward``,
along with some `background operations <https://github.com/pytorch/pytorch/blob/270111b7b611d174967ed204776985cefca9c144/torch/nn/modules/module.py#L866>`_.
Do not call ``model.forward()`` directly!

Calling the model on the input returns a 2-dimensional tensor with dim=0 corresponding to each output of 10 raw predicted values for each class, and dim=1 corresponding to the individual values of each output.
We get the prediction probabilities by passing it through an instance of the ``nn.Softmax`` module.

.. GENERATED FROM PYTHON SOURCE LINES 80-88

.. code-block:: Python


    X = torch.rand(1, 28, 28, device=device)
    logits = model(X)
    pred_probab = nn.Softmax(dim=1)(logits)
    y_pred = pred_probab.argmax(1)
    print(f"Predicted class: {y_pred}")






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Predicted class: tensor([9], device='cuda:0')




.. GENERATED FROM PYTHON SOURCE LINES 89-91

--------------


.. GENERATED FROM PYTHON SOURCE LINES 94-100

Model Layers
-------------------------

Let's break down the layers in the FashionMNIST model. To illustrate it, we
will take a sample minibatch of 3 images of size 28x28 and see what happens to it as
we pass it through the network.

.. GENERATED FROM PYTHON SOURCE LINES 100-104

.. code-block:: Python


    input_image = torch.rand(3,28,28)
    print(input_image.size())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    torch.Size([3, 28, 28])




.. GENERATED FROM PYTHON SOURCE LINES 105-110

nn.Flatten
^^^^^^^^^^^^^^^^^^^^^^
We initialize the `nn.Flatten  <https://pytorch.org/docs/stable/generated/torch.nn.Flatten.html>`_
layer to convert each 2D 28x28 image into a contiguous array of 784 pixel values (
the minibatch dimension (at dim=0) is maintained).

.. GENERATED FROM PYTHON SOURCE LINES 110-115

.. code-block:: Python


    flatten = nn.Flatten()
    flat_image = flatten(input_image)
    print(flat_image.size())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    torch.Size([3, 784])




.. GENERATED FROM PYTHON SOURCE LINES 116-121

nn.Linear
^^^^^^^^^^^^^^^^^^^^^^
The `linear layer <https://pytorch.org/docs/stable/generated/torch.nn.Linear.html>`_
is a module that applies a linear transformation on the input using its stored weights and biases.


.. GENERATED FROM PYTHON SOURCE LINES 121-126

.. code-block:: Python

    layer1 = nn.Linear(in_features=28*28, out_features=20)
    hidden1 = layer1(flat_image)
    print(hidden1.size())






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    torch.Size([3, 20])




.. GENERATED FROM PYTHON SOURCE LINES 127-135

nn.ReLU
^^^^^^^^^^^^^^^^^^^^^^
Non-linear activations are what create the complex mappings between the model's inputs and outputs.
They are applied after linear transformations to introduce *nonlinearity*, helping neural networks
learn a wide variety of phenomena.

In this model, we use `nn.ReLU <https://pytorch.org/docs/stable/generated/torch.nn.ReLU.html>`_ between our
linear layers, but there's other activations to introduce non-linearity in your model.

.. GENERATED FROM PYTHON SOURCE LINES 135-142

.. code-block:: Python


    print(f"Before ReLU: {hidden1}\n\n")
    hidden1 = nn.ReLU()(hidden1)
    print(f"After ReLU: {hidden1}")







.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Before ReLU: tensor([[-0.1935,  0.0892,  0.7276, -0.4309,  0.2546,  0.5260,  0.2330, -0.1461,
             -0.1326, -0.5152, -0.0183, -0.1973,  0.7619,  0.1829,  0.4369,  0.1940,
              0.2094, -0.0634,  0.2466, -0.2544],
            [ 0.1104,  0.2603,  0.4668, -0.4529,  0.1106,  0.4629,  0.0304, -0.1819,
              0.1592, -0.7111,  0.1849, -0.1877,  0.5169,  0.0131,  0.2879,  0.6619,
              0.0542, -0.1319,  0.0292, -0.1560],
            [ 0.2181,  0.2291,  0.7168, -0.5185, -0.4082,  0.3483,  0.1547, -0.1385,
              0.0302, -0.8591,  0.1751, -0.3669,  0.5160,  0.0850,  0.1590,  0.2181,
              0.1079,  0.1623, -0.1423, -0.0619]], grad_fn=<AddmmBackward0>)


    After ReLU: tensor([[0.0000, 0.0892, 0.7276, 0.0000, 0.2546, 0.5260, 0.2330, 0.0000, 0.0000,
             0.0000, 0.0000, 0.0000, 0.7619, 0.1829, 0.4369, 0.1940, 0.2094, 0.0000,
             0.2466, 0.0000],
            [0.1104, 0.2603, 0.4668, 0.0000, 0.1106, 0.4629, 0.0304, 0.0000, 0.1592,
             0.0000, 0.1849, 0.0000, 0.5169, 0.0131, 0.2879, 0.6619, 0.0542, 0.0000,
             0.0292, 0.0000],
            [0.2181, 0.2291, 0.7168, 0.0000, 0.0000, 0.3483, 0.1547, 0.0000, 0.0302,
             0.0000, 0.1751, 0.0000, 0.5160, 0.0850, 0.1590, 0.2181, 0.1079, 0.1623,
             0.0000, 0.0000]], grad_fn=<ReluBackward0>)




.. GENERATED FROM PYTHON SOURCE LINES 143-148

nn.Sequential
^^^^^^^^^^^^^^^^^^^^^^
`nn.Sequential <https://pytorch.org/docs/stable/generated/torch.nn.Sequential.html>`_ is an ordered
container of modules. The data is passed through all the modules in the same order as defined. You can use
sequential containers to put together a quick network like ``seq_modules``.

.. GENERATED FROM PYTHON SOURCE LINES 148-158

.. code-block:: Python


    seq_modules = nn.Sequential(
        flatten,
        layer1,
        nn.ReLU(),
        nn.Linear(20, 10)
    )
    input_image = torch.rand(3,28,28)
    logits = seq_modules(input_image)








.. GENERATED FROM PYTHON SOURCE LINES 159-165

nn.Softmax
^^^^^^^^^^^^^^^^^^^^^^
The last linear layer of the neural network returns `logits` - raw values in [-\infty, \infty] - which are passed to the
`nn.Softmax <https://pytorch.org/docs/stable/generated/torch.nn.Softmax.html>`_ module. The logits are scaled to values
[0, 1] representing the model's predicted probabilities for each class. ``dim`` parameter indicates the dimension along
which the values must sum to 1.

.. GENERATED FROM PYTHON SOURCE LINES 165-170

.. code-block:: Python


    softmax = nn.Softmax(dim=1)
    pred_probab = softmax(logits)









.. GENERATED FROM PYTHON SOURCE LINES 171-180

Model Parameters
-------------------------
Many layers inside a neural network are *parameterized*, i.e. have associated weights
and biases that are optimized during training. Subclassing ``nn.Module`` automatically
tracks all fields defined inside your model object, and makes all parameters
accessible using your model's ``parameters()`` or ``named_parameters()`` methods.

In this example, we iterate over each parameter, and print its size and a preview of its values.


.. GENERATED FROM PYTHON SOURCE LINES 180-187

.. code-block:: Python



    print(f"Model structure: {model}\n\n")

    for name, param in model.named_parameters():
        print(f"Layer: {name} | Size: {param.size()} | Values : {param[:2]} \n")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Model structure: NeuralNetwork(
      (flatten): Flatten(start_dim=1, end_dim=-1)
      (linear_relu_stack): Sequential(
        (0): Linear(in_features=784, out_features=512, bias=True)
        (1): ReLU()
        (2): Linear(in_features=512, out_features=512, bias=True)
        (3): ReLU()
        (4): Linear(in_features=512, out_features=10, bias=True)
      )
    )


    Layer: linear_relu_stack.0.weight | Size: torch.Size([512, 784]) | Values : tensor([[-0.0344,  0.0029, -0.0273,  ...,  0.0078,  0.0008, -0.0210],
            [-0.0178, -0.0264,  0.0266,  ...,  0.0070,  0.0164,  0.0050]],
           device='cuda:0', grad_fn=<SliceBackward0>) 

    Layer: linear_relu_stack.0.bias | Size: torch.Size([512]) | Values : tensor([ 0.0220, -0.0205], device='cuda:0', grad_fn=<SliceBackward0>) 

    Layer: linear_relu_stack.2.weight | Size: torch.Size([512, 512]) | Values : tensor([[ 0.0151, -0.0393, -0.0057,  ...,  0.0107,  0.0261,  0.0305],
            [-0.0197, -0.0242, -0.0284,  ...,  0.0244, -0.0069,  0.0083]],
           device='cuda:0', grad_fn=<SliceBackward0>) 

    Layer: linear_relu_stack.2.bias | Size: torch.Size([512]) | Values : tensor([-0.0089, -0.0239], device='cuda:0', grad_fn=<SliceBackward0>) 

    Layer: linear_relu_stack.4.weight | Size: torch.Size([10, 512]) | Values : tensor([[-0.0398,  0.0290,  0.0263,  ...,  0.0399,  0.0340,  0.0284],
            [ 0.0273,  0.0031,  0.0126,  ...,  0.0268,  0.0312,  0.0242]],
           device='cuda:0', grad_fn=<SliceBackward0>) 

    Layer: linear_relu_stack.4.bias | Size: torch.Size([10]) | Values : tensor([-0.0047, -0.0077], device='cuda:0', grad_fn=<SliceBackward0>) 





.. GENERATED FROM PYTHON SOURCE LINES 188-190

--------------


.. GENERATED FROM PYTHON SOURCE LINES 192-195

Further Reading
-----------------
- `torch.nn API <https://pytorch.org/docs/stable/nn.html>`_


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 0.503 seconds)


.. _sphx_glr_download_beginner_basics_buildmodel_tutorial.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: buildmodel_tutorial.ipynb <buildmodel_tutorial.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: buildmodel_tutorial.py <buildmodel_tutorial.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: buildmodel_tutorial.zip <buildmodel_tutorial.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
